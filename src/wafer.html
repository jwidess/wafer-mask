<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Wafer Art Mask Viewer</title>
  <style>
    /* Base styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    canvas {
      display: block;
      touch-action: none; /* Prevents default touch behaviors */
    }    /* Control panel container */
    .control-panel {
      position: fixed;
      top: 0;
      left: 0;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 0 0 1rem 0;
      z-index: 10;
      max-width: 100%;
      width: 250px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    /* File input styling */
    #imgInput {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 0.5rem;
      border: none;
      font-size: 1rem;
      color: #333;
    }

    /* Preview canvas styling */
    #preview {
      width: 100%;
      max-width: 128px;
      height: 128px;
      border: 2px solid #888;
      background: white;
      image-rendering: pixelated;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
      border-radius: 0.5rem;
    }

    /* Button styles */
    .btn {
      background-color: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #333;
      font-size: 1rem;
      width: 100%;
      text-align: center;
      touch-action: manipulation;
    }

    .btn:hover {
      background-color: rgba(255, 255, 255, 1);
      transform: translateY(-1px);
    }

    .btn.disabled {
      background-color: rgba(80, 80, 80, 0.7);
      color: #ffffff;
    }

    .btn.disabled:hover {
      background-color: rgba(100, 100, 100, 0.8);
    }

    /* Home button */
    .home-button {
      position: fixed;
      top: 0.75rem;
      right: 0.75rem;
      z-index: 10;
      width: auto !important;
      min-width: 80px;
      padding: 0.5rem 1rem;
    }    /* Helper text */
    .helper-text {
      position: fixed;
      top: 0.75rem;
      left: calc(250px + 0.75rem);
      color: white;
      background-color: rgba(255, 100, 100, 0.9);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      z-index: 11;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s ease;
      white-space: nowrap;
    }

    .helper-text.hidden {
      opacity: 0;
    }

    /* Controls group */
    .controls-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }    /* Checkbox and slider styles */
    .control-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: white;
      flex-wrap: wrap;
    }

    /* Special handling for scale control row */
    .control-row:has(input[type="range"]) {
      flex-wrap: nowrap;
    }

    .control-row:has(input[type="range"]) label {
      flex-shrink: 0;
    }

    input[type="checkbox"] {
      width: 1.2rem;
      height: 1.2rem;
    }

    input[type="range"] {
      flex: 1;
      min-width: 80px;
      height: 1.5rem;
    }    input[type="number"] {
      width: 3rem;
      padding: 0.25rem;
      border: none;
      border-radius: 0.25rem;
      text-align: center;
      font-size: 0.9rem;
      flex-shrink: 0;
    }/* Mobile optimizations */
    @media (max-width: 768px) {
      .control-panel {
        width: 200px;
        padding: 0.5rem;
        gap: 0.5rem;
        font-size: 0.9rem;
        max-height: 100vh;
        overflow-y: auto;
      }

      #imgInput {
        padding: 0.35rem;
        font-size: 0.9rem;
      }

      #preview {
        max-width: 96px;
        height: 96px;
      }

      .control-row {
        gap: 0.35rem;
        font-size: 0.9rem;
      }

      input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
      }

      input[type="range"] {
        height: 1.25rem;
      }

      input[type="number"] {
        width: 1.75rem;
        padding: 0.2rem;
        font-size: 0.8rem;
      }

      .btn {
        padding: 0.2rem 0.5rem;
        font-size: 0.8rem;
      }

      .home-button {
        top: 0.5rem;
        right: 0.5rem;
        padding: 0.35rem 0.75rem;
        font-size: 0.9rem;
      }

      .helper-text {
        font-size: 0.85rem;
        padding: 0.35rem 0.5rem;
        left: 210px;
        top: 0.5rem;
      }
    }

    /* Small mobile optimizations */
    @media (max-width: 480px) {
      .control-panel {
        width: 180px;
      }

      .helper-text {
        left: 190px;
      }
    }
  </style>
</head>

<body>
  <a href="https://github.com/jwidess/wafer-mask" class="home-button btn">Home</a>
  <div id="helperText" class="helper-text">&#8592; Choose an image to begin!</div>

  <div class="control-panel">
    <!-- File input -->
    <input type="file" id="imgInput" accept="image/*" />

    <!-- Preview canvas -->
    <canvas id="preview" width="128" height="128"></canvas>

    <!-- Controls groups -->
    <div class="controls-group">
      <!-- Invert mask -->
      <div class="control-row">
        <input type="checkbox" id="invertMask" />
        <label for="invertMask">Invert Mask</label>
      </div>

      <!-- Scale control -->
      <div class="control-row">
        <label for="scaleSlider">Scale:</label>
        <input type="range" id="scaleSlider" min="0.1" max="3" step="0.1" value="1" />
        <input type="number" id="scaleNumber" min="0.1" max="3" step="0.1" value="1" />
      </div>

      <!-- Buttons -->
      <button id="resetScale" class="btn">Reset Scale</button>
      <button id="toggleRotation" class="btn">Disable Auto-Rotate</button>
      <button id="exportImage" class="btn">Export Image</button>
    </div>
  </div>
  
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';

    // === Scene Setup ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // === Camera Setup ===
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 5, 5);

    // === Renderer Setup ===
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // === Controls Setup ===
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    //controls.enablePan = false;  // Disable panning
    controls.target.set(0, 0, 0); // Lock target to center
    controls.target0.set(0, 0, 0); // Lock reset position to center
    controls.update();

    let lastInteraction = Date.now();
    let isAutoRotating = true;
    const AUTO_ROTATION_DELAY = 3000; // 3 seconds

    // Add these event listeners after the controls setup
    controls.addEventListener('start', () => {
      isAutoRotating = false;
      lastInteraction = Date.now();
    });

    controls.addEventListener('end', () => {
      lastInteraction = Date.now();
    });

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // === Wafer Geometry ===
    const RADIUS = 2;
    const THICK = 0.02;
    const topGeo = new THREE.CircleGeometry(RADIUS, 256);
    const bottomGeo = new THREE.CircleGeometry(RADIUS, 256);
    const sideGeo = new THREE.CylinderGeometry(RADIUS, RADIUS, THICK, 256, 1, true);

    // --- Correct UV Remapping for Circle ---
    const uv = topGeo.attributes.uv;
    for (let i = 0; i < uv.count; i++) {
      const x = topGeo.attributes.position.getX(i) / RADIUS;
      const y = topGeo.attributes.position.getY(i) / RADIUS;
      uv.setXY(i, x * 0.5 + 0.5, y * 0.5 + 0.5);
    }
    uv.needsUpdate = true;

    // === Off-Screen Canvas for Mask ===
    const SIZE = 2048;
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = maskCanvas.height = SIZE;
    const mctx = maskCanvas.getContext('2d');

    const maskTex = new THREE.CanvasTexture(maskCanvas);
    maskTex.flipY = false;
    maskTex.wrapS = maskTex.wrapT = THREE.ClampToEdgeWrapping;
    maskTex.minFilter = THREE.LinearMipmapLinearFilter;
    maskTex.magFilter = THREE.LinearFilter;
    maskTex.anisotropy = renderer.capabilities.getMaxAnisotropy();    // === TextureLoader ===
    const loader = new THREE.TextureLoader();
    const silverTex = loader.load('./textures/silver-texture-square.jpg');
    silverTex.wrapS = silverTex.wrapT = THREE.RepeatWrapping;
    silverTex.repeat.set(1, 1);

    // Replace the entire ShaderMaterial definition
    const topMat = new THREE.ShaderMaterial({      uniforms: {
        maskMap: { value: maskTex },
        silverMap: { value: silverTex },
        customCameraPosition: { value: new THREE.Vector3() }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;

        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vNormal = normalize(normalMatrix * normal);
          vViewDir = normalize(cameraPosition - worldPosition.xyz);
          vUv = uv;
          gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        varying vec2 vUv;
          uniform sampler2D maskMap;
        uniform sampler2D silverMap;

        const float iridStrength = 0.5;
        const float iridSaturation = 0.7;
        const float fresnelStrength = 3.0;
        const vec3 lightCol = vec3(0.02, 0.7, 0.02);
        const float bandFrequency = 0.9; // Adjust this to control number of color bands
                                        // Lower values = fewer bands, Higher values = more bands
                                        // Try values between 0.5 and 10.0

        vec4 pal(float t) {
          return 0.5 + 0.5 * cos(6.28318 * bandFrequency * (t + vec4(0.0, 1.0, 2.0, 0.0) / 3.0));
        }

        vec3 greyScale(vec3 color, float lerpVal) {
          float greyCol = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;
          vec3 grey = vec3(greyCol);
          return mix(color, grey, lerpVal);
        }

        void main() {
          vec3 normal = normalize(vNormal);
          vec3 viewDir = normalize(vViewDir);
          
          // Lighting
          vec3 lightPos = vec3(2.0, 2.0, -5.0);
          vec3 lightDir = normalize(-lightPos);
          float ldc = dot(lightDir, -normal);
          vec3 rflct = reflect(normalize(lightPos), normal);
          float spec = dot(rflct, viewDir);
          
          // Fresnel
          float fresnel = 1.0 - dot(normal, viewDir);
          fresnel *= fresnelStrength;          // Sample textures
          float mask = texture2D(maskMap, vUv).r;
          vec3 silverColor = texture2D(silverMap, vUv).rgb;
          
          // Base color with lighting
          vec3 col = (0.4 + 0.3 * ldc + pow(spec, 2.0) * 0.3) * lightCol * 0.3;
          
          // Iridescence
          vec4 irid = pal(fresnel);
          vec3 finalColor = greyScale(irid.rgb, 1.0 - iridSaturation) * iridStrength;
          finalColor *= (1.0 + fresnel * 0.5); // Enhance colors at glancing angles
          
          // Mix between silver and iridescent based on mask
          gl_FragColor = vec4(mix(silverColor, finalColor, mask), 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    // Bottom and side material with grey color
    const greyMaterial = new THREE.MeshStandardMaterial({
      color: 0x808080, // Grey color
      metalness: 0.5,  // Slight metallic look
      roughness: 0.8,  // Matte finish
      side: THREE.DoubleSide // Render both sides
    });

    // Apply the grey material to both bottom and sides
    const bottomMat = greyMaterial;
    const sideMat = greyMaterial;

    // === Meshes ===
    const top = new THREE.Mesh(topGeo, topMat);
    top.rotation.x = -Math.PI / 2;
    top.position.y = THICK / 2;

    const bottom = new THREE.Mesh(bottomGeo, bottomMat);
    bottom.rotation.x = Math.PI / 2;
    bottom.position.y = -THICK / 2;

    const side = new THREE.Mesh(sideGeo, sideMat);

    const wafer = new THREE.Group();
    wafer.add(top, bottom, side);
    scene.add(wafer);

    //scene.add(new THREE.AxesHelper(2));

    // === Preview Canvas ===
    const dctx = document.getElementById('preview').getContext('2d');

    // Add event listener to the "Invert Mask" checkbox
    document.getElementById('invertMask').addEventListener('change', () => {
      console.log('Invert Mask toggled');
      if (currentImage) {
        processImage(currentImage); // Reprocess the current image with the new inversion state
      }
    });

    // Add event listener to the scale slider
    document.getElementById('scaleSlider').addEventListener('input', () => {
      const imgInput = document.getElementById('imgInput');
      if (imgInput.files.length > 0) {
        const event = new Event('change');
        imgInput.dispatchEvent(event);
      }
    });    // Add event listener to the "Reset Scale" button
    document.getElementById('resetScale').addEventListener('click', () => {
      const scaleSlider = document.getElementById('scaleSlider');
      const scaleNumber = document.getElementById('scaleNumber');
      scaleSlider.value = 1; // Reset the slider to its default value
      scaleNumber.value = 1; // Reset the number input to its default value
      if (currentImage) {
        processImage(currentImage); // Reprocess the current image with the default scale
      }
    });

    const defaultImagePath = '../images/seamless-cross-hatch-pattern.jpg';
    let currentImage = null; // Store the currently loaded image

    function processImage(img) {
      const scale = parseFloat(document.getElementById('scaleSlider').value); // Get the scale value
      const aspect = img.width / img.height;
      const w = (aspect >= 1 ? SIZE : SIZE * aspect) * scale;
      const h = (aspect < 1 ? SIZE : SIZE / aspect) * scale;
      const x = (SIZE - w) / 2;
      const y = (SIZE - h) / 2;

      // Clear and prepare the mask canvas
      mctx.clearRect(0, 0, SIZE, SIZE);
      mctx.save();
      mctx.translate(0, SIZE); // Flip vertically
      mctx.scale(1, -1);
      mctx.fillStyle = '#ffffff'; // Fill background with white
      mctx.fillRect(0, 0, SIZE, SIZE);
      mctx.drawImage(img, 0, 0, img.width, img.height, x, y, w, h);
      mctx.restore();

      // Threshold image: dark → white, light → black
      const id = mctx.getImageData(0, 0, SIZE, SIZE);
      const invert = document.getElementById('invertMask').checked; // Check if the mask should be inverted
      for (let i = 0; i < id.data.length; i += 4) {
        const lum = 0.299 * id.data[i] + 0.587 * id.data[i + 1] + 0.114 * id.data[i + 2];
        if (invert ? lum >= 128 : lum < 128) {
          id.data[i] = 255;
          id.data[i + 1] = 255;
          id.data[i + 2] = 255;
        } else {
          id.data[i] = 0;
          id.data[i + 1] = 0;
          id.data[i + 2] = 0;
        }
        id.data[i + 3] = 255; // Fully opaque
      }
      mctx.putImageData(id, 0, 0);

      // === Update Preview Canvas ===
      dctx.clearRect(0, 0, 128, 128);
      dctx.save();

      const previewAspect = img.width / img.height;
      let pWidth = 128, pHeight = 128;
      if (previewAspect >= 1) {
        pHeight = 128 / previewAspect;
      } else {
        pWidth = 128 * previewAspect;
      }
      const pOffsetX = (128 - pWidth) / 2;
      const pOffsetY = (128 - pHeight) / 2;

      // Draw the scaled image onto the preview canvas
      dctx.drawImage(img, 0, 0, img.width, img.height, pOffsetX, pOffsetY, pWidth, pHeight);
      dctx.restore();

      // Refresh Three.js texture
      maskTex.needsUpdate = true;
    }

    // Load the default image on startup
    window.addEventListener('load', () => {
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        processImage(img);
      };
      img.src = defaultImagePath; // Load the default image
    });

    // Update the scale slider logic
    document.getElementById('scaleSlider').addEventListener('input', () => {
      if (currentImage) {
        processImage(currentImage); // Reprocess the current image with the new scale
      }
    });

    // === Image Input & Mask Processing ===
    document.getElementById('imgInput').addEventListener('change', e => {
      // Hide helper text when file is selected
      document.getElementById('helperText').classList.add('hidden');
      
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        currentImage = img; // Update the current image
        processImage(img);
      };
      img.src = URL.createObjectURL(file); // Load the selected image
    });

    // Show helper text again if file input is cleared
    document.getElementById('imgInput').addEventListener('click', () => {
      document.getElementById('helperText').classList.remove('hidden');
    });

    // Add ambient light for general illumination
    const ambientLight = new THREE.AmbientLight(0xffffff, 1); // Soft white light
    scene.add(ambientLight);

    // Add directional light for highlights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Add a point light for better illumination
    const pointLight = new THREE.PointLight(0xffffff, 1, 10); // White light, intensity 1, range 10
    pointLight.position.set(0, 2, 2); // Position above the wafer
    scene.add(pointLight);

    // Sync the number input with the slider
    document.getElementById('scaleSlider').addEventListener('input', (e) => {
      document.getElementById('scaleNumber').value = e.target.value;
      if (currentImage) {
        processImage(currentImage);
      }
    });

    // Sync the slider with the number input
    document.getElementById('scaleNumber').addEventListener('input', (e) => {
      const value = Math.min(Math.max(e.target.value, 0.1), 3);
      document.getElementById('scaleSlider').value = value;
      if (currentImage) {
        processImage(currentImage);
      }
    });

    const CENTER = new THREE.Vector3(0, 0, 0);

    const toggleBtn = document.getElementById('toggleRotation');
    let autoRotateEnabled = true; // Start with auto-rotation enabled

    toggleBtn.addEventListener('click', () => {
      autoRotateEnabled = !autoRotateEnabled;
      toggleBtn.textContent = autoRotateEnabled ? 'Disable Auto-Rotate' : 'Enable Auto-Rotate';
      
      // Toggle the disabled class
      toggleBtn.classList.toggle('disabled', !autoRotateEnabled);

      if (!autoRotateEnabled) {
        isAutoRotating = false;
      }
    });

    // === Animation Loop ===
    // Modify the animation loop to rotate camera instead of wafer
    function animate() {
      requestAnimationFrame(animate);

      // Modify your auto-rotation check in the animate function
      if (!isAutoRotating && autoRotateEnabled && Date.now() - lastInteraction > AUTO_ROTATION_DELAY) {
        isAutoRotating = true;
      }      // Apply auto-rotation if active
      if (isAutoRotating) {
        // Smoothly move target back to center
        controls.target.lerp(CENTER, 0.01);

        // Calculate orbit position
        const radius = Math.sqrt(camera.position.x * camera.position.x + camera.position.z * camera.position.z);
        const angle = Math.atan2(camera.position.x, camera.position.z) + 0.002;

        // Update camera position
        camera.position.x = radius * Math.sin(angle);
        camera.position.z = radius * Math.cos(angle);

        // Make camera look at current target
        camera.lookAt(controls.target);
      }

      topMat.uniforms.customCameraPosition.value.copy(camera.position);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // === Export Image Button Logic ===
    document.getElementById('exportImage').addEventListener('click', () => {
      renderer.render(scene, camera); // Ensure latest frame
      const dataURL = renderer.domElement.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = 'wafer-scene.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  </script>
</body>

</html>
